---
title: "Plan & Execute (1) - 基礎と実装"
emoji: "📋"
type: "tech"
topics: ["ai", "go", "llm", "agent"]
published: false
---

この記事はアドベントカレンダー「LLMセキュリティエージェントの実装」の18日目です。

今回のコードは https://github.com/m-mizutani/leveret の [day18-plan-execute](https://github.com/m-mizutani/leveret/tree/day18-plan-execute) ブランチに格納されていますので適宜参照してください。

# 生成AIエージェントの実行における迷走

- LLMの短く明確なタスクだと、以前に実装したループで


# 生成AIエージェントの行動思考手法

- こうした迷走を防ぐために生成AIエージェントを実行する際にエージェントの行動を制御する手法がいくつか存在する
- LLM Agent Architectures, Reasoning strategiesなどと呼ばれる
- 本アドベントカレンダーでは「行動思考手法」と呼ぶ
  - 行動思考手法は多岐にわたる
- 具体的には、単純にツール実行を繰り返すのではなく、ツール実行の合間にさらに生成AIによるコンテンツ生成を挟み込み、その結果によって次の行動の選択を方法の総評
  - ここまでの要約を与えたり、フルHistoryを与えたりなど手法は様々だが、とにかくタスクの実行とは別に実行方針制御も生成AIでやる、というのがポイント
  - （ここに単純ループと行動思考手法の違いのフローチャートを書く）
- 筆者の認識だとメジャーなものは以下辺り
  - **ReAct (Reason + Act)**:
    - 汎用的に使える思考＋実行を繰り返す手法
    - function callingと比較すると、ReActは思考過程をテキストとしてhistoryに含められる一方、function callingは構造化されたJSON形式で確実にツールを呼び出せる
      - ReActの利点は推論ステップを明示的にプロンプトに示して制御することだが、本質的にはhistory管理の一種である
  - **Plan & Execute**:
    - 計画フェーズと実行フェーズを分離することで計画に沿ったタスクをこなす
    - 安定的に動作する反面、探索的なタスクには弱い
    - 初期計画が静的なため、予期しない状況への適応が困難であり、タスクが順次実行されるため並列化による高速化も制限される
  - **Reflexion**
    - 自己評価・改善ループ型
    - 実行するたびに結果が目的を達成したか？というのを確認し、だめなら内省する
    - それをもとに再実行を繰り返す
    - 探索的な処理に適している
- 研究分野も含めるとより多様な手法がある
- 2025年現在の最新のエージェントでは、これらの手法を組み合わせたり、必要に応じて切り替えたりしながら利用している
  - 例えばタスクによって手法を変えるとか
  - ある手法のなかでのツール実行を別の行動思考手法で制御するとか
  - 万能な行動思考手法はなく、最適手法に関しての研究が進んでいる

# Plan & Executeパターンの利用


- 並列実行は今回扱わない


# まとめ
