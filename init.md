# セキュリティアラート対応LLMエージェント実装 - 25日間アドベントカレンダー

## Day 1: LLMエージェントによるセキュリティ運用の未来（12月1日 月曜日）
**slug: `sec-agent-01-introduction`**

- warrenプロジェクトの紹介と設計思想
- なぜセキュリティアラート対応にLLMエージェントが必要なのか
- 従来の手動対応とSOARツールの限界
- LLMエージェントで実現できる新しいアプローチ
- 開発環境の準備（Go、必要なツール、API キー）
- 25日間で構築するシステムの全体像

## Day 2: 小規模SOCチームが直面する現実的課題（12月2日 火曜日）
**slug: `sec-agent-02-challenges`**

- アラート疲労：大量の通知と限られたリソース
- 繰り返し作業の負担：同じような調査の繰り返し
- 定型化の困難さ：すべてを自動化できない現実
- 従来のSOARツールの問題点：厳密なワークフロー定義とメンテナンスコスト
- LLMで解決できること：柔軟な分析、自然言語での指示
- LLMで解決できないこと：最終判断、新規脅威の評価
- 人間とAIの適切な分担戦略

## Day 3: システムアーキテクチャと設計方針（12月3日 水曜日）
**slug: `sec-agent-03-architecture`**

- CLI中心のアーキテクチャ選択理由
- コンポーネント分割：CLI、ツール層、LLM層、ストレージ層
- データモデル設計：アラート、エンリッチメント結果、会話履歴、ポリシー
- データフロー：入力→分析→エンリッチ→判断→記録
- LLM活用戦略：どの処理にLLMを使い、どこで使わないか
- プロンプト設計の基本方針
- 拡張性を考慮した設計判断

## Day 4: 開発環境とベースコード理解（12月4日 木曜日）
**slug: `sec-agent-04-setup`**

- Goプロジェクトの構造説明
- urfave/cli/v3の基本的な使い方
- 用意されたベースコードの読み解き
- コマンド構造：analyze、chat、list、policy等
- 設定ファイル管理（YAML）とシークレット管理
- ツール全体の構造理解：internal/パッケージ構成
- 開発フロー：ビルド、実行、デバッグ

## Day 5: LLM統合の第一歩 - アラート要約（12月5日 金曜日）
**slug: `sec-agent-05-llm-basics`**

- OpenAI/Gemini API接続の実装
- APIクライアントの設計
- シンプルなプロンプトでアラート要約
- レスポンスの取得とパース
- エラーハンドリングの基本
- トークン数の意識とコスト管理
- 実際のアラートJSONで動作確認

## Day 6: 構造化出力でIOCを抽出する（12月6日 土曜日）
**slug: `sec-agent-06-structured-output`**

- JSON形式での出力指定
- Structured Output APIの活用
- IOC（IP、ドメイン、ハッシュ）の抽出実装
- 攻撃種別の推定
- 出力スキーマの設計とバリデーション
- パース失敗時のフォールバック戦略
- 抽出結果のデータベース保存

## Day 7: プロンプトチューニングの基礎（12月7日 日曜日）
**slug: `sec-agent-07-prompt-tuning`**

- プロンプトエンジニアリングとは
- 基礎的なコンテキスト付与の技法
- Few-shot Learning：具体例を示して精度向上
- 要約品質の改善：フォーマット指定、対象読者の明示
- IOC抽出の精度向上：良い例と悪い例の提示
- システムメッセージの効果的な活用
- プロンプトのバージョン管理

## Day 8: 会話履歴の管理基盤（12月8日 月曜日）
**slug: `sec-agent-08-conversation-history`**

- 会話履歴のデータ構造設計
- メッセージの追加と取得
- SQLiteでの永続化実装
- セッション管理：開始、継続、終了
- 履歴の検索と参照
- 最新N件の効率的な取得
- 後続の圧縮処理に備えた設計

## Day 9: Function Callingで外部ツールと連携（12月9日 火曜日）
**slug: `sec-agent-09-function-calling`**

- Function Callingの仕組みと利点
- ツール定義：名前、説明、パラメータスキーマ
- JSON Schemaでのパラメータ定義
- LLMへのツールリスト提供
- ツール呼び出しリクエストの受信と解析
- ツール実行と結果のフィードバック
- 複数回のツール呼び出しループ実装

## Day 10: 脅威インテリジェンスツールの実装（12月10日 水曜日）
**slug: `sec-agent-10-threat-intel`**

- AlienVault OTX APIの統合
- URLScan.io APIの統合
- AbuseIPDB APIの統合
- 統一インターフェースの設計
- レート制限への対応戦略
- APIキーの管理
- 結果の正規化と構造化
- エラー時のフォールバック

## Day 11: MCPで拡張可能なツール基盤（12月11日 木曜日）
**slug: `sec-agent-11-mcp`**

- Model Context Protocol (MCP) とは
- なぜMCPが必要か：標準化の利点
- MCPサーバーの実装：ログ検索サーバー例
- ツールの公開：利用可能なツールのリスト提供
- MCPクライアントの実装
- 既存ツールのMCP化
- 他システムとの相互運用性

## Day 12: ログDBアクセスとコンテキストエンジニアリング（12月12日 金曜日）
**slug: `sec-agent-12-log-db`**

- ログデータベース連携の設計
- スキーマ情報をプロンプトに含める技法
- テーブル構造、カラム、サンプルデータの提示
- 自然言語からSQLクエリ生成
- クエリの検証とサニタイゼーション
- 実行時間制限とタイムアウト
- クエリ結果の要約と提示

## Day 13: 大量データの圧縮技術（12月13日 土曜日）
**slug: `sec-agent-13-data-compaction`**

- 入力データcompactionの必要性
- 長大なログデータの要約手法
- 大量アラートの集約方法
- Map-Reduce的な分割処理パターン
- クエリベースの選択的抽出
- 階層的要約：詳細→要約→超要約
- LLMコンテキストに収まるサイズへの圧縮

## Day 14: 会話コンテキストの圧縮戦略（12月14日 日曜日）
**slug: `sec-agent-14-context-compression`**

- トークン制限の課題
- 会話履歴の要約による圧縮
- 構造化抽出：JSON形式での事実保存
- セマンティック選択：関連性の高いメッセージだけ残す
- Embeddingを使った類似度ベース選択
- 圧縮レベルの動的調整
- 圧縮による情報損失のトレードオフ

## Day 15: Open Policy Agentとrego入門（12月15日 月曜日）
**slug: `sec-agent-15-opa-rego`**

- OPA (Open Policy Agent) とは
- Regoの基本文法とルール記述
- アラートフィルタリングポリシーの実装
- 条件に基づくアラート変換
- 複数ルールの組み合わせ
- ポリシーの動的読み込み
- CLIからのポリシー評価実行

## Day 16: ポリシーベースの自動アクション（12月16日 火曜日）
**slug: `sec-agent-16-action-policy`**

- Alert PolicyとAction Policyのチェーン
- 分析前の任意自動実行の仕組み
- 条件に応じたツール呼び出し
- アクション結果を次の判断材料に
- AlertChainパターンの実装
- 複雑なワークフローの実現
- 実例：特定条件でのエンリッチメント自動実行

## Day 17: AI支援によるポリシー開発（12月17日 水曜日）
**slug: `sec-agent-17-ai-policy-dev`**

- 生成AIコーディングエージェントの活用
- Claude Codeを使ったポリシー開発フロー
- 自然言語でのルール記述依頼
- ポリシーの反復改善
- ポリシーテストケースの作成（YAML形式）
- `agent policy test` コマンドの実装
- CI/CDへの組み込みとリグレッション防止

## Day 18: Plan & Execute (1) - 基礎概念（12月18日 木曜日）
**slug: `sec-agent-18-plan-execute-basics`**

- Plan & Executeパターンとは
- ReActとの違い：事前計画 vs 逐次思考
- 複雑なタスクの分解方法
- シンプルな順次実行の実装
- 実行計画のJSON生成
- 各ステップの実行と結果記録
- 全体像の理解と動作確認

## Day 19: Plan & Execute (2) - 複雑な計画立案（12月19日 金曜日）
**slug: `sec-agent-19-plan-execute-advanced`**

- 依存関係の管理：先行条件の定義
- 並列実行可能なステップの識別
- 複雑な計画の生成プロンプト設計
- タスクグラフの構築
- 実行順序の最適化
- 実行進捗の可視化
- 実例：多段階のアラート調査フロー

## Day 20: Plan & Execute (3) - 動的再計画（12月20日 土曜日）
**slug: `sec-agent-20-plan-execute-replanning`**

- 実行結果の評価方法
- 計画の成功/失敗判定
- エラー発生時のリカバリー戦略
- 動的な再計画：新情報に基づく修正
- 無限ループの防止：最大反復回数
- 終了条件の設計と制御
- デバッグとトラブルシューティング

## Day 21: Embeddingによる類似アラート検索（12月21日 日曜日）
**slug: `sec-agent-21-embedding-similarity`**

- Embedding APIの利用（OpenAI/Gemini）
- アラートのベクトル化戦略
- ベクトルのストレージ設計
- コサイン類似度の計算
- 類似アラート検索の実装
- 過去の対応チケット検索
- 閾値のチューニングと精度評価
- LLMへのコンテキスト提供での活用

## Day 22: ツールの信頼性を高めるテスト戦略（12月22日 月曜日）
**slug: `sec-agent-22-testing`**

- なぜツールのテストが重要か
- モックツールの実装パターン
- ユニットテスト：個別ツールの動作検証
- 統合テスト：ツール間の連携確認
- エラーケーステスト：タイムアウト、レート制限、API障害
- LLMレスポンスのモック化
- テーブル駆動テストの活用
- CI/CDでの自動テスト実行

## Day 23: エージェントの判断精度を測る（12月23日 火曜日）
**slug: `sec-agent-23-evaluation`**

- エージェント評価の重要性
- 判断精度の測定方法：正解データとの比較
- 実行ログの分析とトレース
- 成功率・失敗率の計測
- プロンプト改善サイクルの確立
- A/Bテストによる比較評価
- フィードバックループの構築
- 継続的な品質改善アプローチ

## Day 24: WebUIとSlack連携の設計（12月24日 水曜日）
**slug: `sec-agent-24-ui-integration`**

- warrenのWebUI/Slack統合アプローチ（解説）
- GraphQL APIの設計：Query、Mutation、Subscription
- Slack Botアーキテクチャ
- インタラクティブコンポーネント：ボタン、モーダル
- リアルタイム可視化：WebSocketでのストリーミング
- エージェント実行状況の表示
- Plan & Executeステップの可視化
- CLIからの拡張方針

## Day 25: システム総括とマルチエージェントの未来（12月25日 木曜日）
**slug: `sec-agent-25-future`**

- 25日間の振り返り：構築したシステムの全体像
- 学んだ技術の整理：LLM、ツール、ポリシー、Plan & Execute
- warrenとの比較：実装した機能と残された機能
- マルチエージェントシステムの可能性
- 専門化エージェントの協調：Triage、Investigation、Forensics、Response
- Human-in-the-loop設計パターン
- エージェントセキュリティの考慮事項
- 拡張アーキテクチャと今後のチャレンジ
