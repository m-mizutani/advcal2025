# セキュリティアラート対応生成AIエージェント実装 - 全体構成

このドキュメントは、2025年12月のアドベントカレンダー「Goで作るセキュリティ分析生成AIエージェント」の全体構成をまとめたものです。実際に執筆済みの記事(Day 1-9)の内容を反映し、今後の記事(Day 10-25)の方向性を示します。

## プロジェクト概要

**目的**: セキュリティアラート分析を支援する生成AIエージェントをGoで実装し、その過程を通じて生成AIエージェント構築の実践的知識を習得する

**ターゲット読者**:
- 生成AIエージェントを自力で構築してみたい人
- セキュリティ分析領域での生成AI活用に興味がある人
- Go言語で生成AI関連の実装をしたい人

**技術スタック**:
- 言語: Go 1.25+
- 生成AI: Google Gemini API (Vertex AI経由)
- データベース: Firestore (メタデータ、ベクトル検索)
- ストレージ: Cloud Storage (会話履歴)
- ポリシーエンジン: Open Policy Agent (Rego)

**リファレンス実装**: https://github.com/m-mizutani/leveret

---

## 第1週: 基礎編 - LLM統合と会話管理 (Day 1-7)

### ✅ Day 1: はじめに - セキュリティアラート分析と生成AIエージェント
**slug**: `sec-agent-01-introduction`

**内容**:
- 本アドベントカレンダーの目的と対象読者
- セキュリティアラート対応の課題
- 生成AIエージェントによる解決アプローチ
- warrenプロジェクトとの関係
- 25日間で構築するシステムの全体像

**キーポイント**:
- アラート対応の初期分析、発報調整、結果整理の自動化
- LangChainを使わないGoベースでのフルスクラッチ実装
- CLI中心の最小構成版を構築

---

### ✅ Day 2: セキュリティアラートの分析業務における課題と生成AIによる改善の可能性
**slug**: `sec-agent-02-challenges`

**内容**:
- アラート疲労の実態と統計データ
- 専門知識不足という現実的課題
- SOARの限界：厳密なワークフロー定義とメンテナンスコスト
- 分析業務の複雑さと柔軟性の必要性
- 生成AIで解決できること、できないこと

**キーポイント**:
- SOCでも44%のアラートが未調査という現実
- SOARの「幻滅期」とプレイブック管理の困難さ
- 生成AIによる柔軟なデータ収集と動的判断の可能性
- 人間とAIの適切な分担戦略

---

### ✅ Day 3: システムアーキテクチャと設計方針
**slug**: `sec-agent-03-architecture`

**内容**:
- CLI中心アーキテクチャの選択理由
- レイヤードアーキテクチャ設計
- コンポーネント分割（CLI、UseCase、Repository、Adapter、Model層）
- 生成AI活用戦略：使う場面と使わない場面
- アラートとポリシーのデータモデル
- 処理フローとアラートのライフサイクル

**キーポイント**:
- 学習と理解の容易さを重視したCLI設計
- 生成AIは「柔軟性が必要な判断」に、ルールベースは「決定性が必要な処理」に
- Function CallingによるLLMとツールの連携
- FirestoreとCloud Storageによるデータ管理

---

### ✅ Day 4: 開発環境の準備と事前実装済みコードの説明
**slug**: `sec-agent-04-setup`

**内容**:
- Go開発環境のセットアップ
- Google Cloud環境構築（Firestore、Cloud Storage、Vertex AI）
- ADC（Application Default Credentials）認証
- Budget Alertsの設定
- ベースコードの構造説明
- コマンド構造と基本動作確認
- 環境変数管理ツール（zenv）の活用

**キーポイント**:
- `init`ブランチからスタート、段階的に機能追加
- レイヤードアーキテクチャの実装例
- 環境変数による設定の一元管理

---

### ✅ Day 5: 生成AI利用の基礎とアラートの説明文の作成
**slug**: `sec-agent-05-llm-basics`

**内容**:
- Gemini APIクライアントの設計
- `GenerateContent`の基本的な使い方
- アラートのタイトルと要約の自動生成
- エラーハンドリング（トークン数、コンテンツフィルタリング）
- リトライ機構の実装
- プロンプト管理（`embed`と`text/template`）

**キーポイント**:
- 生成AIは「命令通り動く装置」ではなく、検証とリトライが必須
- 失敗情報を次のリクエストに活用することで成功率向上
- プロンプトの外部ファイル化とテンプレート管理

---

### ✅ Day 6: 構造化データ出力でIoCなど属性値を抽出する
**slug**: `sec-agent-06-structured-output`

**内容**:
- 構造化データ出力の必要性
- `ResponseMIMEType`と`ResponseSchema`の活用
- IoC（IP、ドメイン、ハッシュ）の抽出実装
- Attribute構造体の設計とバリデーション
- タイトル・要約・属性を一度のAPI呼び出しで取得
- 抽出の過不足とプロンプトチューニング

**キーポイント**:
- 複数項目を一度に取得してAPI呼び出し回数を削減
- JSON Schemaで型と必須フィールドを制約
- 生成AIによる柔軟なIoC抽出で多様なアラートスキーマに対応

---

### ✅ Day 7: 会話と履歴の管理
**slug**: `sec-agent-07-conversation-history`

**内容**:
- 生成AIにおける「会話」の仕組み
- 会話履歴のデータ構造（`Content`と`Role`）
- 履歴の永続化戦略（メタデータとコンテンツの分離）
- Cloud Storageへの履歴保存と読み込み
- チャット機能の実装
- System promptによるアラートデータの提供
- 会話タイトルの自動生成

**キーポイント**:
- 会話は「履歴を全て含めて毎回送信」する仕組み
- メタデータ（Firestore）とコンテンツ（Cloud Storage）の分離でコスト最適化
- トークン数とコストは会話の長さに対して累積的に増加

---

## 第2週: 中級編 - ツール連携とプロンプトエンジニアリング (Day 8-14)

### ✅ Day 8: Function Callingによる外部ツール連携
**slug**: `sec-agent-08-function-calling`

**内容**:
- Function Callingとは何か
- なぜFunction Callingが必要か（必要に応じたデータ読込、複雑な処理、外部データストア操作）
- `FunctionDeclaration`の構造（Name、Description、Parameters）
- アラート検索ツールの実装
- ツール実行ループと制御
- エラーハンドリングのエージェント的アプローチ

**キーポイント**:
- Function Callingはコード制御との適切な使い分けが重要
- ツール定義のNameとDescriptionが生成AIの判断精度を左右
- エラーもフィードバックとして扱い、生成AIに次の行動を判断させる

---

### 🔧 Day 9: 脅威インテリジェンスツールの実装
**slug**: `sec-agent-09-threat-intel`
**status**: 執筆中 (published: false)

**内容**:
- ツール利用の抽象化（Toolインターフェース）
- Registryパターンによる複数ツールの統一管理
- AlienVault OTX APIの統合実装
- Function Declarationの定義（命名とパラメータ設計）
- ツール実行処理とエラーハンドリング
- レート制限への対応戦略
- 他の脅威インテリジェンス（URLScan.io、AbuseIPDB）への言及

**キーポイント**:
- Toolインターフェース（Flags、Init、Spec、Prompt、Execute）による拡張性
- ツール名の重複チェックとRegistryによる一元管理
- 入力検証の重要性（生成AIからの入力も信頼できないデータとして扱う）
- エラーメッセージに詳細なコンテキストを含めて生成AIの判断を支援

---

### 🚧 Day 10: MCPで拡張可能なツール基盤
**slug**: `sec-agent-10-mcp`
**status**: 未着手 (見出しのみ)

**予定内容**:
- Model Context Protocol (MCP) とは
- なぜMCPが必要か：標準化の利点
- MCPサーバーの実装：ログ検索サーバー例
- ツールの公開：利用可能なツールのリスト提供
- MCPクライアントの実装
- 既存ツールのMCP化
- 他システムとの相互運用性

**想定キーポイント**:
- MCPによる標準化で他のツールやシステムと連携可能に
- サーバー/クライアント方式でツールの配布と共有が容易
- 生成AIエージェントエコシステムへの参加

---

### 🚧 Day 11: プロンプトチューニングの基礎
**slug**: `sec-agent-11-prompt-tuning`
**status**: 未着手 (見出しのみ)

**予定内容**:
- プロンプトエンジニアリングとは
- ツール選択精度の向上：Few-shot Learning
- パラメータ抽出の改善：具体例の提示
- 要約品質の改善：フォーマット指定、対象読者の明示
- IoC抽出の精度向上：良い例と悪い例の提示
- System Messageの効果的活用
- プロンプトのバージョン管理と評価

**想定キーポイント**:
- Few-shot Learningで期待する動作を例示
- プロンプトの構造化（Markdown見出し）で理解しやすく
- 段階的なプロンプト改善とバージョン管理

---

### 🚧 Day 12: ログDBアクセスとコンテキストエンジニアリング
**slug**: `sec-agent-12-log-db`

**内容**:
- ログデータベース連携の設計
- スキーマ情報をプロンプトに含める技法
- テーブル構造、カラム、サンプルデータの提示
- 自然言語からSQLクエリ生成
- クエリの検証とサニタイゼーション
- 実行時間制限とタイムアウト
- クエリ結果の要約と提示

**キーポイント**:
- データベーススキーマを効果的にプロンプトに組み込む
- 生成AIによる自然言語→SQLクエリ変換
- セキュリティ（SQLインジェクション対策）と安全性（タイムアウト）

---

### 🚧 Day 13: 大量データの圧縮技術
**slug**: `sec-agent-13-data-compaction`

**内容**:
- 入力データcompactionの必要性
- 長大なログデータの要約手法
- 大量アラートの集約方法
- Map-Reduce的な分割処理パターン
- クエリベースの選択的抽出
- 階層的要約：詳細→要約→超要約
- LLMコンテキストに収まるサイズへの圧縮

**キーポイント**:
- コンテキストウィンドウの制約に対する実践的な対処法
- データを段階的に要約して圧縮
- 必要な情報を選択的に抽出

---

### 🚧 Day 14: 会話コンテキストの圧縮戦略
**slug**: `sec-agent-14-context-compression`

**内容**:
- トークン制限の課題
- 会話履歴の要約による圧縮
- 構造化抽出：JSON形式での事実保存
- セマンティック選択：関連性の高いメッセージだけ残す
- Embeddingを使った類似度ベース選択
- 圧縮レベルの動的調整
- 圧縮による情報損失のトレードオフ

**キーポイント**:
- 長期的な会話でのコンテキスト管理
- 重要な情報を保持しつつトークン数を削減
- Embedding活用で意味的に重要な履歴を優先

---

## 第3週: 上級編 - ポリシー駆動とPlan-Execute (Day 15-21)

### 🚧 Day 15: Open Policy Agentとrego入門
**slug**: `sec-agent-15-opa-rego`

**内容**:
- OPA (Open Policy Agent) とは
- Regoの基本文法とルール記述
- アラートフィルタリングポリシーの実装
- 条件に基づくアラート変換
- 複数ルールの組み合わせ
- ポリシーの動的読み込み
- CLIからのポリシー評価実行

**キーポイント**:
- 決定性のある判定をRegoで実装
- ポリシーを外部ファイルとして管理し、再ビルド不要
- 生成AIとルールベース処理の組み合わせ

---

### 🚧 Day 16: ポリシーベースの自動アクション
**slug**: `sec-agent-16-action-policy`

**内容**:
- Alert PolicyとAction Policyのチェーン
- 分析前の自動実行の仕組み
- 条件に応じたツール呼び出し
- アクション結果を次の判断材料に
- AlertChainパターンの実装
- 複雑なワークフローの実現
- 実例：特定条件でのエンリッチメント自動実行

**キーポイント**:
- ポリシーで条件を定義し、アクションを自動化
- 生成AIとポリシーエンジンの協調動作
- 柔軟性と決定性のバランス

---

### 🚧 Day 17: AI支援によるポリシー開発
**slug**: `sec-agent-17-ai-policy-dev`

**内容**:
- 生成AIコーディングエージェントの活用
- Claude Codeを使ったポリシー開発フロー
- 自然言語でのルール記述依頼
- ポリシーの反復改善
- ポリシーテストケースの作成（YAML形式）
- `agent policy test` コマンドの実装
- CI/CDへの組み込みとリグレッション防止

**キーポイント**:
- 生成AIでRegoポリシーの開発を効率化
- テスト駆動でポリシーの品質を担保
- ポリシー開発の民主化（非エンジニアでもルール作成可能）

---

### 🚧 Day 18: Plan & Execute (1) - 基礎概念
**slug**: `sec-agent-18-plan-execute-basics`

**内容**:
- Plan & Executeパターンとは
- ReActとの違い：事前計画 vs 逐次思考
- 複雑なタスクの分解方法
- シンプルな順次実行の実装
- 実行計画のJSON生成
- 各ステップの実行と結果記録
- 全体像の理解と動作確認

**キーポイント**:
- 事前に計画を立ててから実行する戦略
- タスク分解による複雑な調査の構造化
- 計画と実行の分離

---

### 🚧 Day 19: Plan & Execute (2) - 複雑な計画立案
**slug**: `sec-agent-19-plan-execute-advanced`

**内容**:
- 依存関係の管理：先行条件の定義
- 並列実行可能なステップの識別
- 複雑な計画の生成プロンプト設計
- タスクグラフの構築
- 実行順序の最適化
- 実行進捗の可視化
- 実例：多段階のアラート調査フロー

**キーポイント**:
- DAG（有向非巡回グラフ）で依存関係を管理
- 並列実行による効率化
- 複雑な分析シナリオの自動化

---

### 🚧 Day 20: Plan & Execute (3) - 動的再計画
**slug**: `sec-agent-20-plan-execute-replanning`

**内容**:
- 実行結果の評価方法
- 計画の成功/失敗判定
- エラー発生時のリカバリー戦略
- 動的な再計画：新情報に基づく修正
- 無限ループの防止：最大反復回数
- 終了条件の設計と制御
- デバッグとトラブルシューティング

**キーポイント**:
- 実行結果に応じた計画の動的修正
- 失敗時のリカバリーと代替手段の探索
- サーキットブレーカーによる安全性確保

---

### 🚧 Day 21: Embeddingによる類似アラート検索
**slug**: `sec-agent-21-embedding-similarity`

**内容**:
- Embedding APIの利用（Gemini）
- アラートのベクトル化戦略
- ベクトルのストレージ設計（Firestore Vector Search）
- コサイン類似度の計算
- 類似アラート検索の実装
- 過去の対応チケット検索
- 閾値のチューニングと精度評価
- LLMへのコンテキスト提供での活用

**キーポイント**:
- Embeddingによる意味的な類似性検索
- 過去の対応履歴を活用した分析支援
- Firestoreのベクトル検索機能を活用

---

## 第4週: 実践編 - テスト、評価、統合 (Day 22-25)

### 🚧 Day 22: ツールの信頼性を高めるテスト戦略
**slug**: `sec-agent-22-testing`

**内容**:
- なぜツールのテストが重要か
- モックツールの実装パターン
- ユニットテスト：個別ツールの動作検証
- 統合テスト：ツール間の連携確認
- エラーケーステスト：タイムアウト、レート制限、API障害
- LLMレスポンスのモック化
- テーブル駆動テストの活用
- CI/CDでの自動テスト実行

**キーポイント**:
- 生成AIエージェントのテスタビリティ
- モックとスタブによる外部依存の分離
- エラーケースの網羅的テスト

---

### 🚧 Day 23: エージェントの判断精度を測る
**slug**: `sec-agent-23-evaluation`

**内容**:
- エージェント評価の重要性
- 判断精度の測定方法：正解データとの比較
- 実行ログの分析とトレース
- 成功率・失敗率の計測
- プロンプト改善サイクルの確立
- A/Bテストによる比較評価
- フィードバックループの構築
- 継続的な品質改善アプローチ

**キーポイント**:
- 生成AIの確率的な性質に対する評価戦略
- 定量的な指標によるプロンプト改善
- 継続的な評価と改善のサイクル

---

### 🚧 Day 24: WebUIとSlack連携の設計
**slug**: `sec-agent-24-ui-integration`

**内容**:
- warrenのWebUI/Slack統合アプローチ（解説）
- GraphQL APIの設計：Query、Mutation、Subscription
- Slack Botアーキテクチャ
- インタラクティブコンポーネント：ボタン、モーダル
- リアルタイム可視化：WebSocketでのストリーミング
- エージェント実行状況の表示
- Plan & Executeステップの可視化
- CLIからの拡張方針

**キーポイント**:
- CLI実装をベースにしたUI統合の考え方
- 非同期処理とストリーミング
- ユーザー体験の向上

---

### 🚧 Day 25: システム総括とマルチエージェントの未来
**slug**: `sec-agent-25-future`

**内容**:
- 25日間の振り返り：構築したシステムの全体像
- 学んだ技術の整理：LLM、ツール、ポリシー、Plan & Execute
- warrenとの比較：実装した機能と残された機能
- マルチエージェントシステムの可能性
- 専門化エージェントの協調：Triage、Investigation、Forensics、Response
- Human-in-the-loop設計パターン
- エージェントセキュリティの考慮事項
- 拡張アーキテクチャと今後のチャレンジ

**キーポイント**:
- 生成AIエージェント構築の全体像の振り返り
- 実務での適用に向けた考慮事項
- マルチエージェントとエージェント間協調の展望

---

## 技術トピック索引

### LLM基礎
- Day 5: GenerateContent、プロンプト管理、リトライ
- Day 6: 構造化出力、ResponseSchema
- Day 7: 会話履歴、System prompt
- Day 11: プロンプトチューニング、Few-shot Learning

### ツール連携
- Day 8: Function Calling基礎、アラート検索
- Day 9: Toolインターフェース、Registry、脅威インテリジェンス
- Day 10: MCP（Model Context Protocol）
- Day 12: ログDB連携、SQL生成

### データ管理
- Day 3: データモデル設計
- Day 4: Firestore、Cloud Storage
- Day 7: 会話履歴の永続化
- Day 13-14: データ圧縮、コンテキスト圧縮
- Day 21: Embedding、ベクトル検索

### ポリシー駆動
- Day 15: OPA/Rego入門
- Day 16: ポリシーベース自動アクション
- Day 17: AI支援ポリシー開発

### 高度なパターン
- Day 18-20: Plan & Execute
- Day 21: Embedding類似検索

### 品質保証
- Day 22: テスト戦略
- Day 23: 評価手法

### 統合・展望
- Day 24: UI/Slack連携
- Day 25: マルチエージェント、今後の展望

---

## リファレンス

### プロジェクトリポジトリ
- メインリポジトリ: https://github.com/m-mizutani/leveret
- warren (参考実装): https://github.com/secmon-lab/warren

### ブランチ戦略
- `init`: 開発のベースコード
- `day01-*` ～ `day25-*`: 各日の実装
- `main`: 完成版

## 記事執筆の進捗状況

### ✅ 完了 (Day 1-8)
- 基礎編が完了し、LLM統合、会話管理、Function Callingまで実装済み
- すべて published: true で公開可能状態

### 🔧 執筆中 (Day 9)
- 脅威インテリジェンスツールの実装記事は本文完成
- Toolインターフェース、Registryパターン、AlienVault OTX統合を詳細解説
- published: false のため最終レビュー待ち

### 🚧 未着手 (Day 10-25)
- すべて見出しのみで本文未記述
- Day 10以降の執筆が必要

---

### 執筆期限（status.ymlより）
- Day 9: 執筆期限 2025-11-03、公開期限 2025-12-08
- Day 10: 執筆期限 2025-11-06、公開期限 2025-12-09
- Day 11: 執筆期限 2025-11-09、公開期限 2025-12-10
- 以降も3日間隔で設定
