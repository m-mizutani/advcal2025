# セキュリティアラート対応生成AIエージェント実装 - 全体構成

このドキュメントは、2025年12月のアドベントカレンダー「Goで作るセキュリティ分析生成AIエージェント」の全体構成をまとめたものです。実際に執筆済みの記事(Day 1-9)の内容を反映し、今後の記事(Day 10-25)の方向性を示します。

## プロジェクト概要

**目的**: セキュリティアラート分析を支援する生成AIエージェントをGoで実装し、その過程を通じて生成AIエージェント構築の実践的知識を習得する

**ターゲット読者**:
- 生成AIエージェントを自力で構築してみたい人
- セキュリティ分析領域での生成AI活用に興味がある人
- Go言語で生成AI関連の実装をしたい人

**技術スタック**:
- 言語: Go 1.25+
- 生成AI: Google Gemini API (Vertex AI経由)
- データベース: Firestore (メタデータ、ベクトル検索)
- ストレージ: Cloud Storage (会話履歴)
- ポリシーエンジン: Open Policy Agent (Rego)

**リファレンス実装**: https://github.com/m-mizutani/leveret

---

## 第1週: 基礎編 - LLM統合と会話管理 (Day 1-7)

### ✅ Day 1: はじめに - セキュリティアラート分析と生成AIエージェント
**slug**: `sec-agent-01-introduction`

**内容**:
- 本アドベントカレンダーの目的と対象読者
- セキュリティアラート対応の課題
- 生成AIエージェントによる解決アプローチ
- warrenプロジェクトとの関係
- 25日間で構築するシステムの全体像

**キーポイント**:
- アラート対応の初期分析、発報調整、結果整理の自動化
- LangChainを使わないGoベースでのフルスクラッチ実装
- CLI中心の最小構成版を構築

---

### ✅ Day 2: セキュリティアラートの分析業務における課題と生成AIによる改善の可能性
**slug**: `sec-agent-02-challenges`

**内容**:
- アラート疲労の実態と統計データ
- 専門知識不足という現実的課題
- SOARの限界：厳密なワークフロー定義とメンテナンスコスト
- 分析業務の複雑さと柔軟性の必要性
- 生成AIで解決できること、できないこと

**キーポイント**:
- SOCでも44%のアラートが未調査という現実
- SOARの「幻滅期」とプレイブック管理の困難さ
- 生成AIによる柔軟なデータ収集と動的判断の可能性
- 人間とAIの適切な分担戦略

---

### ✅ Day 3: システムアーキテクチャと設計方針
**slug**: `sec-agent-03-architecture`

**内容**:
- CLI中心アーキテクチャの選択理由
- レイヤードアーキテクチャ設計
- コンポーネント分割（CLI、UseCase、Repository、Adapter、Model層）
- 生成AI活用戦略：使う場面と使わない場面
- アラートとポリシーのデータモデル
- 処理フローとアラートのライフサイクル

**キーポイント**:
- 学習と理解の容易さを重視したCLI設計
- 生成AIは「柔軟性が必要な判断」に、ルールベースは「決定性が必要な処理」に
- Function CallingによるLLMとツールの連携
- FirestoreとCloud Storageによるデータ管理

---

### ✅ Day 4: 開発環境の準備と事前実装済みコードの説明
**slug**: `sec-agent-04-setup`

**内容**:
- Go開発環境のセットアップ
- Google Cloud環境構築（Firestore、Cloud Storage、Vertex AI）
- ADC（Application Default Credentials）認証
- Budget Alertsの設定
- ベースコードの構造説明
- コマンド構造と基本動作確認
- 環境変数管理ツール（zenv）の活用

**キーポイント**:
- `init`ブランチからスタート、段階的に機能追加
- レイヤードアーキテクチャの実装例
- 環境変数による設定の一元管理

---

### ✅ Day 5: 生成AI利用の基礎とアラートの説明文の作成
**slug**: `sec-agent-05-llm-basics`

**内容**:
- Gemini APIクライアントの設計
- `GenerateContent`の基本的な使い方
- アラートのタイトルと要約の自動生成
- エラーハンドリング（トークン数、コンテンツフィルタリング）
- リトライ機構の実装
- プロンプト管理（`embed`と`text/template`）

**キーポイント**:
- 生成AIは「命令通り動く装置」ではなく、検証とリトライが必須
- 失敗情報を次のリクエストに活用することで成功率向上
- プロンプトの外部ファイル化とテンプレート管理

---

### ✅ Day 6: 構造化データ出力でIoCなど属性値を抽出する
**slug**: `sec-agent-06-structured-output`

**内容**:
- 構造化データ出力の必要性
- `ResponseMIMEType`と`ResponseSchema`の活用
- IoC（IP、ドメイン、ハッシュ）の抽出実装
- Attribute構造体の設計とバリデーション
- タイトル・要約・属性を一度のAPI呼び出しで取得
- 抽出の過不足とプロンプトチューニング

**キーポイント**:
- 複数項目を一度に取得してAPI呼び出し回数を削減
- JSON Schemaで型と必須フィールドを制約
- 生成AIによる柔軟なIoC抽出で多様なアラートスキーマに対応

---

### ✅ Day 7: 会話と履歴の管理
**slug**: `sec-agent-07-conversation-history`

**内容**:
- 生成AIにおける「会話」の仕組み
- 会話履歴のデータ構造（`Content`と`Role`）
- 履歴の永続化戦略（メタデータとコンテンツの分離）
- Cloud Storageへの履歴保存と読み込み
- チャット機能の実装
- System promptによるアラートデータの提供
- 会話タイトルの自動生成

**キーポイント**:
- 会話は「履歴を全て含めて毎回送信」する仕組み
- メタデータ（Firestore）とコンテンツ（Cloud Storage）の分離でコスト最適化
- トークン数とコストは会話の長さに対して累積的に増加

---

## 第2週: 中級編 - ツール連携とデータ管理 (Day 8-14)

### ✅ Day 8: Function Callingによる外部ツール連携
**slug**: `sec-agent-08-function-calling`

**内容**:
- Function Callingとは何か
- なぜFunction Callingが必要か（必要に応じたデータ読込、複雑な処理、外部データストア操作）
- `FunctionDeclaration`の構造（Name、Description、Parameters）
- アラート検索ツールの実装
- ツール実行ループと制御
- エラーハンドリングのエージェント的アプローチ

**キーポイント**:
- Function Callingはコード制御との適切な使い分けが重要
- ツール定義のNameとDescriptionが生成AIの判断精度を左右
- エラーもフィードバックとして扱い、生成AIに次の行動を判断させる

---

### ✅ Day 9: シンプルなツールの実装：脅威インテリジェンスツール
**slug**: `sec-agent-09-threat-intel`
**status**: 完了 (published: true)

**内容**:
- ツール利用の抽象化（Toolインターフェース）
- Registryパターンによる複数ツールの統一管理
- AlienVault OTX APIの統合実装
- Function Declarationの定義（命名とパラメータ設計）
- ツール実行処理とエラーハンドリング
- レート制限への対応戦略
- 他の脅威インテリジェンス（URLScan.io、AbuseIPDB）への言及

**キーポイント**:
- Toolインターフェース（Flags、Init、Spec、Prompt、Execute）による拡張性
- ツール名の重複チェックとRegistryによる一元管理
- 入力検証の重要性（生成AIからの入力も信頼できないデータとして扱う）
- エラーメッセージに詳細なコンテキストを含めて生成AIの判断を支援

---

### 🚧 Day 10: MCPで拡張可能なツール基盤
**slug**: `sec-agent-10-mcp`
**status**: 未着手 (見出しのみ)

**予定内容**:
- Model Context Protocol (MCP) とは
- なぜMCPが必要か：標準化の利点
- MCPサーバーの実装：ログ検索サーバー例
- ツールの公開：利用可能なツールのリスト提供
- MCPクライアントの実装
- 既存ツールのMCP化
- 他システムとの相互運用性

**想定キーポイント**:
- MCPによる標準化で他のツールやシステムと連携可能に
- サーバー/クライアント方式でツールの配布と共有が容易
- 生成AIエージェントエコシステムへの参加

---

### ✅ Day 11: より実践的なツールの実装：BigQueryからのログ取得
**slug**: `sec-agent-11-log-db`
**status**: 完了 (published: true)

**内容**:
- BigQueryアクセスツールの設計
- スキーマ情報をプロンプトに含める技法
- テーブル構造、カラム、サンプルデータの提示
- 自然言語からSQLクエリ生成
- クエリの検証とサニタイゼーション
- 実行時間制限とタイムアウト
- クエリ結果の要約と提示
- Lost in the Middle現象とスキーマ配置の最適化

**キーポイント**:
- データベーススキーマを効果的にプロンプトに組み込む
- 生成AIによる自然言語→SQLクエリ変換
- セキュリティ（SQLインジェクション対策）と安全性（タイムアウト）
- 段階的なツール実行（スキーマ取得→クエリ実行）

---

### ✅ Day 12: エージェントのプロンプトエンジニアリング
**slug**: `sec-agent-12-prompt-engineering`
**status**: 完了 (published: true)

**内容**:
- プロンプトエンジニアリングの重要性
- セキュリティ分析エージェントの役割と目的の定義
- 背景情報の提示（環境情報、データ構造）
- 分析における指針やルールの定義（Investigation Methodology）
- ツール使用ガイドラインと自律的調査の指示
- 出力形式の定義（Findings、Assessment、Knowledge Gaps、Recommended Actions、Conclusion）
- プロンプトテンプレート管理（text/template、embed）
- その他の考慮事項（生成AI活用、言語選択、情報配置とLost in the Middle）

**キーポイント**:
- 役割を定義しつつも推論だけでの結論を避ける制約の設定
- 段階的な情報収集を促すツール使用ガイドライン
- 事実と推論を分離した構造化出力形式
- プロンプト自体の生成AI活用と調整
- 英語プロンプト+日本語出力の言語戦略
- 重要情報の配置最適化（冒頭・末尾優先）

---

### 🚧 Day 13: 会話コンテキストの圧縮戦略
**slug**: `sec-agent-13-context-compression`

**内容**:
- トークン制限の課題
- 会話履歴の要約による圧縮
- 構造化抽出：JSON形式での事実保存
- セマンティック選択：関連性の高いメッセージだけ残す
- 圧縮レベルの動的調整
- 圧縮による情報損失のトレードオフ

**キーポイント**:
- 長期的な会話でのコンテキスト管理
- 重要な情報を保持しつつトークン数を削減
- 意味的に重要な履歴を優先

---

### 🚧 Day 14: サブエージェントアーキテクチャ
**slug**: `sec-agent-14-subagent`

**内容**:
- サブエージェントの概念と必要性
- タスクの専門化：IoC調査、ログ分析など
- エージェント間の通信パターン
- 親エージェントによるオーケストレーション
- 並列実行と結果の集約
- サブエージェントの実装例
- エラーハンドリングと部分的失敗への対応

**キーポイント**:
- 複雑なタスクを専門化されたサブエージェントに分散
- エージェント間の疎結合な設計
- Plan & Executeへの導線

---

## 第3週: 上級編 - ポリシー駆動、Plan-Execute、記憶システム (Day 15-21)

### 🚧 Day 15: ポリシー駆動アーキテクチャ
**slug**: `sec-agent-15-policy-driven`

**内容**:
- ポリシー駆動アーキテクチャとは
- OPA (Open Policy Agent) の概要（詳細はドキュメント参照）
- Regoによるポリシー記述の基礎
- アラートフィルタリングポリシーの実装
- ポリシーベースの自動アクション
- Alert PolicyとAction Policyのチェーン
- 条件に応じたツール自動実行
- ポリシーの動的読み込みとテスト

**キーポイント**:
- 決定性のある判定をポリシーエンジンで実装
- 生成AIとルールベース処理の適切な使い分け
- ポリシーを外部ファイルとして管理し、再ビルド不要
- Regoの詳細は参考文献を紹介

---

### 🚧 Day 16: Plan & Execute (1) - 基礎概念
**slug**: `sec-agent-16-plan-execute-basics`

**内容**:
- Plan & Executeパターンとは
- ReActとの違い：事前計画 vs 逐次思考
- 複雑なタスクの分解方法
- シンプルな順次実行の実装
- 実行計画のJSON生成
- 各ステップの実行と結果記録
- 全体像の理解と動作確認

**キーポイント**:
- 事前に計画を立ててから実行する戦略
- タスク分解による複雑な調査の構造化
- 計画と実行の分離

---

### 🚧 Day 17: Plan & Execute (2) - 複雑な計画立案
**slug**: `sec-agent-17-plan-execute-advanced`

**内容**:
- 依存関係の管理：先行条件の定義
- 並列実行可能なステップの識別
- 複雑な計画の生成プロンプト設計
- タスクグラフの構築
- 実行順序の最適化
- 実行進捗の可視化
- 実例：多段階のアラート調査フロー

**キーポイント**:
- DAG（有向非巡回グラフ）で依存関係を管理
- 並列実行による効率化
- 複雑な分析シナリオの自動化

---

### 🚧 Day 18: Plan & Execute (3) - 動的再計画
**slug**: `sec-agent-18-plan-execute-replanning`

**内容**:
- 実行結果の評価方法
- 計画の成功/失敗判定
- エラー発生時のリカバリー戦略
- 動的な再計画：新情報に基づく修正
- 無限ループの防止：最大反復回数
- 終了条件の設計と制御
- デバッグとトラブルシューティング

**キーポイント**:
- 実行結果に応じた計画の動的修正
- 失敗時のリカバリーと代替手段の探索
- サーキットブレーカーによる安全性確保

---

### 🚧 Day 19: Embeddingによる類似アラート検索
**slug**: `sec-agent-19-embedding-similarity`

**内容**:
- Embedding APIの利用（Gemini）
- アラートのベクトル化戦略
- ベクトルのストレージ設計（Firestore Vector Search）
- コサイン類似度の計算
- 類似アラート検索の実装
- 過去の対応チケット検索
- 閾値のチューニングと精度評価
- LLMへのコンテキスト提供での活用

**キーポイント**:
- Embeddingによる意味的な類似性検索
- 過去の対応履歴を活用した分析支援
- Firestoreのベクトル検索機能を活用

---

### 🚧 Day 20: エージェントの記憶システム
**slug**: `sec-agent-20-memory-system`

**内容**:
- 短期記憶と長期記憶の概念
- ナレッジベースの設計と実装
- 分析結果の永続化戦略
- Embeddingを活用した記憶の保存と検索
- RAG（Retrieval-Augmented Generation）パターン
- 記憶の更新と忘却の戦略
- 過去の知見を活用した分析精度向上
- 記憶の一貫性とバージョン管理

**キーポイント**:
- 会話履歴（短期記憶）とナレッジベース（長期記憶）の分離
- Embeddingによる意味的な記憶検索
- 学習した知見の蓄積と再利用
- 記憶を活用したコンテキスト拡張

---

### 🚧 Day 21: エラーハンドリングとリカバリー戦略
**slug**: `sec-agent-21-error-handling`

**内容**:
- エージェントの失敗パターン分類
- ツール実行エラーへの対応
- LLM API障害とタイムアウト処理
- 自動リトライとバックオフ戦略
- フォールバック機構の設計
- 部分的成功の扱い方
- 人間へのエスカレーション設計
- エラー状況の記録と学習

**キーポイント**:
- エラーを予期し適切にハンドリング
- グレースフルデグラデーション（段階的な機能低下）
- リトライとフォールバックの使い分け
- Human-in-the-loopパターンの実装

---

## 第4週: 実践編 - テスト、評価、統合 (Day 22-25)

### 🚧 Day 22: ツールの信頼性を高めるテスト戦略
**slug**: `sec-agent-22-testing`

**内容**:
- なぜツールのテストが重要か
- モックツールの実装パターン
- ユニットテスト：個別ツールの動作検証
- 統合テスト：ツール間の連携確認
- エラーケーステスト：タイムアウト、レート制限、API障害
- LLMレスポンスのモック化
- テーブル駆動テストの活用
- CI/CDでの自動テスト実行

**キーポイント**:
- 生成AIエージェントのテスタビリティ
- モックとスタブによる外部依存の分離
- エラーケースの網羅的テスト

---

### 🚧 Day 23: エージェントの判断精度を測る
**slug**: `sec-agent-23-evaluation`

**内容**:
- エージェント評価の重要性
- 判断精度の測定方法：正解データとの比較
- 実行ログの分析とトレース
- 成功率・失敗率の計測
- プロンプト改善サイクルの確立
- A/Bテストによる比較評価
- フィードバックループの構築
- 継続的な品質改善アプローチ

**キーポイント**:
- 生成AIの確率的な性質に対する評価戦略
- 定量的な指標によるプロンプト改善
- 継続的な評価と改善のサイクル

---

### 🚧 Day 24: WebUIとSlack連携の設計
**slug**: `sec-agent-24-ui-integration`

**内容**:
- warrenのWebUI/Slack統合アプローチ（解説）
- GraphQL APIの設計：Query、Mutation、Subscription
- Slack Botアーキテクチャ
- インタラクティブコンポーネント：ボタン、モーダル
- リアルタイム可視化：WebSocketでのストリーミング
- エージェント実行状況の表示
- Plan & Executeステップの可視化
- CLIからの拡張方針

**キーポイント**:
- CLI実装をベースにしたUI統合の考え方
- 非同期処理とストリーミング
- ユーザー体験の向上

---

### 🚧 Day 25: システム総括とマルチエージェントの未来
**slug**: `sec-agent-25-future`

**内容**:
- 25日間の振り返り：構築したシステムの全体像
- 学んだ技術の整理：LLM、ツール、ポリシー、Plan & Execute
- warrenとの比較：実装した機能と残された機能
- マルチエージェントシステムの可能性
- 専門化エージェントの協調：Triage、Investigation、Forensics、Response
- Human-in-the-loop設計パターン
- エージェントセキュリティの考慮事項
- 拡張アーキテクチャと今後のチャレンジ

**キーポイント**:
- 生成AIエージェント構築の全体像の振り返り
- 実務での適用に向けた考慮事項
- マルチエージェントとエージェント間協調の展望

---

## 技術トピック索引

### LLM基礎
- Day 5: GenerateContent、プロンプト管理、リトライ
- Day 6: 構造化出力、ResponseSchema
- Day 7: 会話履歴、System prompt

### ツール連携
- Day 8: Function Calling基礎、アラート検索
- Day 9: Toolインターフェース、Registry、脅威インテリジェンス
- Day 10: MCP（Model Context Protocol）
- Day 11: ログDB連携、SQL生成

### データ管理
- Day 3: データモデル設計
- Day 4: Firestore、Cloud Storage
- Day 7: 会話履歴の永続化
- Day 12: 大量データ圧縮
- Day 13: 会話コンテキスト圧縮
- Day 19: Embedding、ベクトル検索
- Day 20: 記憶システム、ナレッジベース

### アーキテクチャパターン
- Day 14: サブエージェント
- Day 15: ポリシー駆動アーキテクチャ
- Day 16-18: Plan & Execute
- Day 21: エラーハンドリングとリカバリー

### 品質保証
- Day 22: テスト戦略
- Day 23: 評価手法

### 統合・展望
- Day 24: UI/Slack連携
- Day 25: マルチエージェント、今後の展望

---

## リファレンス

### プロジェクトリポジトリ
- メインリポジトリ: https://github.com/m-mizutani/leveret
- warren (参考実装): https://github.com/secmon-lab/warren

### ブランチ戦略
- `init`: 開発のベースコード
- `day01-*` ～ `day25-*`: 各日の実装
- `main`: 完成版

## 記事執筆の進捗状況

### ✅ 完了 (Day 1-12)
- 基礎編が完了し、LLM統合、会話管理、Function Calling、MCP、BigQueryツール、プロンプトエンジニアリングまで実装済み
- すべて published: true で公開可能状態

### 🚧 未着手 (Day 13-25)
- すべて見出しのみで本文未記述
- Day 13以降の執筆が必要

---

## 構成変更のサマリー（2025-11-03更新）

### Week 2（Day 8-14）の変更
- **削除**: Day 11「プロンプトチューニング」→ 各記事で必要に応じて言及
- **変更**: Day 11 ← Day 12「ログDBアクセス」（コンテキストエンジニアリング部分は独立させず統合）
- **変更**: Day 12 ← Day 13「大量データ圧縮」
- **変更**: Day 13 ← Day 14「会話コンテキスト圧縮」
- **新規**: Day 14「サブエージェントアーキテクチャ」

### Week 3（Day 15-21）の変更
- **統合**: Day 15「ポリシー駆動アーキテクチャ」（旧Day 15 OPA/Rego + 旧Day 16自動アクション）
  - OPA/Regoの詳細は参考文献扱い、実装パターンに焦点
- **削除**: Day 17「AI支援ポリシー開発」→ 必要に応じてDay 15に統合
- **変更**: Day 16-18 ← 旧Day 18-20「Plan & Execute (1)(2)(3)」
- **変更**: Day 19 ← 旧Day 21「Embedding類似検索」
- **新規**: Day 20「エージェントの記憶システム」
  - 短期/長期記憶、ナレッジベース、RAGパターン
- **新規**: Day 21「エラーハンドリングとリカバリー戦略」
  - 失敗パターン分類、リトライ、フォールバック、エスカレーション

### 主要な狙い
1. AIエージェントの本質的トピック（記憶、サブエージェント、エラー処理）に焦点
2. OPA/Regoは「使える技術」として紹介、詳細解説は避ける
3. データ圧縮→サブエージェント→Plan & Executeの自然な流れ
4. Embedding→記憶システムの依存関係を明確化

---

### 執筆期限（status.ymlより）
- Day 11: 執筆期限 2025-11-09、公開期限 2025-12-10
- Day 12: 執筆期限 2025-11-12、公開期限 2025-12-11
- Day 13: 執筆期限 2025-11-15、公開期限 2025-12-12
- 以降も3日間隔で設定
